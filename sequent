Package sequent

=============================================
                  export
=============================================

Expect
  valid?: Formula -> Boolean

    %: valid?(f) is true if formula f is valid.
%Expect

=============================================
%%             Binary operators
=============================================

Operator 
  |-  (++);
  \/  (+);
  /\  (*);
  ==> (opL5)
%Operator

=============================================
%%             Formula
=============================================

Type Formula =
    vbl String
  | neg Formula
  | Formula /\ Formula
  | Formula \/ Formula
  | Formula ==> Formula
with
  $, show, ==
%Type

=============================================
%%             Sequent
=============================================

Type Sequent =
  [Formula] |- [Formula]
with
  $, show, ==
%Type

=============================================
                implementation
=============================================

Import "collect/search".

Abbrev Rule = Sequent -> Maybe of [Sequent].

=============================================
%%                isBasic
=============================================

Expect isBasic: Sequent -> Boolean
  %: isBasic(s) returns true if formula occurs 
  %: on the left and rigth hand of list.
%Expect

Define 
----------------------------------------------
  case isBasic (a |- b) = someSatisfy (x |-> x `in` b) a.
----------------------------------------------
  
Example isBasic ([vbl "x"] |- [vbl "x", vbl "y"]) = true.
Example isBasic ([vbl "x", vbl "z"] |- [vbl "y"]) = false.

=============================================
%%                  negL
=============================================

Expect negL: Sequent -> Maybe of [Sequent]
  %: negL(s) is the inference used to represent
  %: negative operator to the left of Sequent s.
%Expect

Define
----------------------------------------------
  case negL (neg x :: alpha |- beta) = something [alpha |- x :: beta]
----------------------------------------------
  case negL (?) = nothing
----------------------------------------------
%Define
Example negL ([vbl "x"] |- [vbl "y"]) = nothing.
Example negL ([neg(vbl "z"), vbl "x"] |- [vbl "y"]) =
           something [[vbl "x"] |- [vbl "z", vbl "y"]].

=============================================
%%                 negR
=============================================

Expect negR: Sequent -> Maybe of [Sequent]
  %: negR(s) is the inference, used to represent
  %: negative operator to the rigth of Sequent s
%Expect

Define
----------------------------------------------
  case negR (alpha |- neg x :: beta) = something [x :: alpha |- beta]
----------------------------------------------
  case negR (?) = nothing
----------------------------------------------
%Define
Example negR ([vbl "x"] |- [vbl "y"]) = nothing.
Example negR ([vbl "x"] |- [neg(vbl "z"), vbl "y"]) =
          something [[vbl "z", vbl "x"] |- [ vbl "y"]].

=============================================
%%                   andL
=============================================

Expect andL: Sequent -> Maybe of [Sequent]
  %: andL(s) is the inference used to represent
  %: conjunction operator to the left of Sequent s.
%Expect

Define
----------------------------------------------
  case andL ((x /\ y) :: alpha |- beta) = something [x :: y :: alpha |- beta]
----------------------------------------------
  case andL (?) = nothing

%Define
Example andL ([vbl "x"] |- [vbl "y"]) = nothing.
Example andL ([(vbl "x"/\ vbl "y"),vbl "x"] |- [vbl "y"]) = something
          [[vbl "x", vbl "y", vbl "x"] |- [vbl "y"]].

=============================================
%%                   andR
=============================================

Expect andR: Sequent -> Maybe of [Sequent]
  %: andR(s) is the inference used to represent
  %: conjunction operator to the tigth of Sequent s.
%Expect

Define
----------------------------------------------
  case andR (alpha |- (x /\ y) :: beta) = something [alpha |- x :: beta, alpha |- y :: beta]
----------------------------------------------
  case andR (?) = nothing
----------------------------------------------
%Define
Example andR ([vbl "x"] |- [vbl "y"]) = nothing.
Example andL ([vbl "x"] |- [(vbl "x" /\ vbl "y"), vbl "y"]) = something
          [[vbl "x"] |- [vbl "y", vbl "y"]].

=============================================
%%                   orL
=============================================

Expect orL: Sequent -> Maybe of [Sequent]
  %: orL(s) is the inference used to represent
  %: disjunction operator to the left of Sequent s.
%Expect

Define
----------------------------------------------
  case orL ((x \/ y) :: alpha |- beta) = something [x :: alpha |- beta, y :: alpha |- beta]
----------------------------------------------
  case orL (?) = nothing
----------------------------------------------
%Define
Example orL ([vbl "x", vbl "z"] |- [vbl "z"]) = nothing.
Example orL ([(vbl "x" \/ vbl "y"), vbl "z"] |- [vbl "z"]) = something
          [[vbl "x", vbl "z"] |- [vbl "z"],
          [vbl "y", vbl "z"] |- [vbl "z"]].

=============================================
%%                  orR
=============================================

Expect orR: Sequent -> Maybe of [Sequent]
  %: orL(s) is the inference used to represent
  %: disjunction operator to the tigth of Sequent s.
%Expect

Define
----------------------------------------------
  case orR (alpha |- (x \/ y) :: beta) = something [alpha |- x :: y :: beta]
----------------------------------------------
  case orR (?) = nothing

%Define

Example orR ([vbl "x"] |- [vbl "y"]) = nothing.
Example orR ([vbl "x"] |- [(vbl "y" \/ vbl "z"), vbl "w"]) = something
          [[vbl "x"] |- [vbl "y", vbl "z", vbl "w"]].
=============================================
%%                  impL
=============================================

Expect impL: Sequent -> Maybe of [Sequent]
  %: orL(s) is the inference used to represent
  %: implication operator to the left of Sequent s.
%Expect

Define
----------------------------------------------
  case impL ((x ==> y) :: alpha |- beta) = something [alpha |- x :: beta, y :: alpha |- beta]
----------------------------------------------
  case impL (?) = nothing
----------------------------------------------
%Define
Example impL ([vbl "x"] |- [vbl "y"]) = nothing.
Example impL ([(vbl "x" ==> vbl "y"), vbl "z"] |- [vbl "w"]) = something
          [[vbl "z"] |- [vbl "x", vbl "w"],
           [vbl "y", vbl "z"] |- [vbl "w"]].
          
=============================================
%%                  impR
=============================================

Expect impR: Sequent -> Maybe of [Sequent]
  %: orL(s) is the inference used to represent
  %: implication operator to the tigth of Sequent s.
%Expect

Define
----------------------------------------------
  case impR (alpha |- (x ==> y) :: beta) = something [x :: alpha |- y :: beta]
----------------------------------------------
  case impR (?) = nothing

%Define
Example impR ([vbl "x"] |- [vbl "y"]) = nothing.
Example impR ([vbl "x"] |- [(vbl "y" ==> vbl "z"), vbl "w"]) = something
          [[vbl "y", vbl "x"] |- [vbl "z", vbl "w"]].

=============================================
%%               inferable
=============================================

Expect inferable: Formula -> Boolean
  %: inferable(f) is true if formula contains
  %: a logical operator.
%Expect
----------------------------------------------
Define inferable (formula) = not vbl?(formula).
----------------------------------------------

Example inferable (vbl "x" /\  vbl "y") = true.

=============================================
%%              inferFormula
=============================================

Expect inferFormula: [Formula] -> Boolean
  %: inferFormula is true if list of formulas
  %: contains at least one inferable formula.
%Expect
----------------------------------------------
Define inferFormula (formula) = someSatisfy (x |-> inferable(x)) formula.
----------------------------------------------
Example inferFormula ([vbl "x", vbl "y"]) = false.
=============================================
%%              inferToFront
=============================================

Expect inferToFront: [Formula] -> [Formula]
  %: inferToFront yields the list of formulas
  %: moved to the front of formula list L. 
  %:If there is no inferable formula in alpha
  %: the unchanged list is returned.
%Expect

Define
  %%case inferToFront(alpha,beta) = alpha :: (beta -/ alph).
  case inferToFront (alpha) = alpha when not inferFormula (alpha)
  case inferToFront (alpha) = beta | ! y = (select (x |-> inferable(x)) alpha).
    ! beta = y :: alpha -/ y.
%Define

=============================================
%%                 isValid
=============================================

Expect isValid: (Maybe of [Sequent]) -> Boolean.
%: returns true if all sequent in list is valid.

Define
  case isValid (something (alpha)) = allSatisfy (x |-> validSequent(x)) alpha
  case isValid (?) = false
%Define

=============================================
%%              tryRules
=============================================
%: tries each rule fom on the sequent
%: if rule is aplicable then, it will be used to 
%: get new goals and retest the new goals.
Expect tryRules: (Sequent, [Rule]) -> Boolean.

Define
  case tryRules (alpha, h :: t) = isValid(h(alpha)) or tryRules(alpha, t)
  case tryRules (?, []) = false
%Define

=============================================
%%              inferLeft
=============================================
%: returns true if one of the sequent to the left 
%: is valid
Expect inferLeft: Sequent -> Boolean.

Define inferLeft (alpha) = tryRules (alpha, [negL, andL, orL, impL]).

=============================================
%%             inferRight
=============================================
%: returns true if one of the sequent to the rigth 
%: is valid
Expect inferRight: Sequent -> Boolean.

Define inferRight (alpha) = tryRules (alpha, [negR, andR, orR, impR]).

=============================================
%%                infer
=============================================
%:returns true when some rules in sequent is valid
Expect infer: Sequent -> Boolean.

Define infer (alpha |- beta)
  = inferLeft(inferToFront(alpha) |- beta) or inferRight(alpha |- inferToFront(beta)).

=============================================
%%             validSequent
=============================================
%: takes a sequent anr returns wheather the 
%: sequen is valid or not

Expect validSequent: Sequent -> Boolean.

Define validSequent (alpha) = isBasic(alpha) or infer(alpha).

=============================================
%%               valid?
=============================================

Define 
  valid? (alpha) = validSequent([] |- [alpha]).

%Package
