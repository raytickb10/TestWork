%% Brian Raytick
%% CSCI 3675
%% 11/01/2016

Package sequent

=============================================
                  export
=============================================

Expect
  valid?: Formula -> Boolean

    %: valid?(f) is true if formula f is valid.
%Expect

=============================================
%%             Binary operators
=============================================

Operator 
  |-  (++);
  \/  (+);
  /\  (*);
  ==> (opL5)
%Operator

=============================================
%%             Formula
=============================================

Type Formula =
    vbl String
  | neg Formula
  | Formula /\ Formula
  | Formula \/ Formula
  | Formula ==> Formula
with
  $, show, ==
%Type

=============================================
%%             Sequent
=============================================

Type Sequent =
  [Formula] |- [Formula]
with
  $, show, ==
%Type

Expect
  valid?: Formula -> Boolean

    %: valid?(f) is true if formula f is valid.
%Expect

=============================================
                implementation
=============================================

Import "collect/search".

Abbrev 
  MaybeSequents = Maybe of [Sequent];
  FormulaTester = Formula -> Boolean;
  Rule          = Sequent -> MaybeSequents
%Abbrev

=============================================
%%             isBasic
=============================================

Expect isBasic: Sequent -> Boolean
  %: isBasic(s) will return true if the formula on left of
  %: Sequent s also occurs on the right.
%Expect

Define
  ----------------------------------------------
  case isBasic (a |- b) = someSatisfy (x |-> x `in` b) a.
  ----------------------------------------------

Example isBasic ([vbl "P"] |- [vbl "P", vbl "Q"]) = true.
Example isBasic ([vbl "P", vbl "R"] |- [vbl "Q"]) = false.

=============================================
%%             negL
=============================================

Expect negL: Sequent -> Maybe of [Sequent]
  %: negL(s) is the inference used to represent the
  %: negative operator left of Sequent s.
%Expect

Define
  --------------------------------------------
  case negL (neg x :: a |- b) = something [a |- x :: b]
  case negL (?) = nothing
  --------------------------------------------
%Define

Example negL ([neg(vbl "P"), vbl "Q"] |- [vbl "R"])
  = something [[vbl "Q"] |- [vbl "P", vbl "R"]].
Example negL ([vbl "Q"] |- [vbl "R"]) = nothing.

=============================================
%%             negR
=============================================

Expect negR: Sequent -> Maybe of [Sequent]
  %: negR(s) is the inference, used to represent the
  %: negative operator to the right of Sequent s
%Expect

Define
  --------------------------------------------  
  case negR (a |- neg x :: b) = something [x :: a |- b]
  case negR (?) = nothing
  --------------------------------------------
%Define

Example negR ([vbl "Q"] |- [neg(vbl "P"), vbl "R"])
  = something [[vbl "P", vbl "Q"] |- [vbl "R"]].
Example negR ([vbl "Q"] |- [vbl "R"]) = nothing.

=============================================
%%             andL
=============================================

Expect andL: Sequent -> Maybe of [Sequent]
  %: andL(s) is the inference used to represent the
  %: conjunction operator to the left of Sequent s.
%Expect

Define
  --------------------------------------------
  case andL ((x /\ y) :: a |- b) = something [x :: y :: a |- b]
  case andL (?) = nothing
  --------------------------------------------
%Define

Example andL ([vbl "P"] |- [vbl "Q"]) = nothing.
Example andL ([(vbl "P"/\ vbl "Q"),vbl "P"] |- [vbl "Q"]) = something [[vbl "P", vbl "Q", vbl "P"] |- [vbl "Q"]].

=============================================
%%             andR
=============================================

Expect andR: Sequent -> Maybe of [Sequent]
  %: andR(s) is the inference used to represent the
  %: conjunction operator to the right of Sequent s.
%Expect

Define
  --------------------------------------------
  case andR (a |- (x /\ y) :: b) = something [a |- x :: b, a |- y :: b]
  case andR (?) = nothing
  --------------------------------------------
%Define

Example andR ([vbl "P", vbl "Q"] |- [vbl "P"]) = nothing.
Example andR ([vbl "P"] |- [(vbl "P" /\ vbl "Q"), vbl "Q"])
  = something [[vbl "P"] |- [vbl "P", vbl "Q"], [vbl "P"] |- [vbl "Q", vbl "Q"]].

=============================================
%%             orL
=============================================

Expect orL: Sequent -> Maybe of [Sequent]
  %: orL(s) is the inference used to represent the
  %: disjunction operator to the left of Sequent s.
%Expect

Define
  --------------------------------------------
  case orL ((x \/ y) :: a |- b) = something [x :: a |- b, y :: a |- b]
  case orL (?) = nothing
  --------------------------------------------
%Define

Example orL ([vbl "P", vbl "R"] |- [vbl "R"]) = nothing.
Example orL ([(vbl "P" \/ vbl "Q"), vbl "R"] |- [vbl "R"]) = something
          [[vbl "P", vbl "R"] |- [vbl "R"],[vbl "Q", vbl "R"] |- [vbl "R"]].

=============================================
%%             orR
=============================================

Expect orR: Sequent -> Maybe of [Sequent]
  %: orL(s) is the inference used to represent the
  %: disjunction operator to the right of Sequent s.
%Expect

Define
  --------------------------------------------
  case orR (a |- (x \/ y) :: b) = something [a |- x :: y :: b]
  case orR (?) = nothing
  --------------------------------------------
%Define

Example orR ([vbl "P"] |- [vbl "Q"]) = nothing.
Example orR ([vbl "P"] |- [(vbl "Q" \/ vbl "R"), vbl "O"]) = something
          [[vbl "P"] |- [vbl "Q", vbl "R", vbl "O"]].

=============================================
%%             impL
=============================================

Expect impL: Sequent -> Maybe of [Sequent]
  %: orL(s) is the inference used to represent the
  %: implication operator to the left of Sequent s.
%Expect

Define
  --------------------------------------------
  case impL ((x ==> y) :: a |- b) = something [a |- x :: b, y :: a |- b]
  case impL (?) = nothing
  --------------------------------------------
%Define

Example impL([vbl "P", vbl "R"] |- [vbl "R"]) = nothing.
Example impL([(vbl "R" ==> vbl "P"), vbl "Q"] |- [vbl "P"])
  = something [[vbl "Q"] |- [vbl "R", vbl "P"],
               [vbl "P", vbl "Q"] |- [vbl "P"]].

=============================================
%%             impR
=============================================

Expect impR: Sequent -> Maybe of [Sequent]
  %: orL(s) is the inference used to represent the
  %: implication operator to the right of Sequent s.
%Expect

Define
  --------------------------------------------
  case impR (a |- (x ==> y) :: b) = something [x :: a |- y :: b]
  case impR (?) = nothing
  --------------------------------------------
%Define

Example impR([vbl "P", vbl "R"] |- [vbl "R"]) = nothing.
Example impR([vbl "Q"] |- [(vbl "R" ==> vbl "Q"), vbl "P"])
  = something [[vbl "R", vbl "Q"] |- [vbl "Q", vbl "P"]].

=============================================
%%             inferable
=============================================

Expect inferable: Formula -> Boolean
  %: inferable(f) is true if formula f contains
  %: a logical operator.
%Expect

--------------------------------------------
Define inferable (f) = not vbl?(f).
--------------------------------------------

Example inferable (vbl "P" \/ vbl "Q") = true.

=============================================
%%             inferFormula
=============================================

Expect inferFormula: [Formula] -> Boolean
  %: inferFormula(alpha) is true if list of formulas alpha
  %: contains at least one inferable formula.
%Expect

--------------------------------------------
Define inferFormula (alpha) = someSatisfy (x |-> inferable(x)) alpha.
--------------------------------------------

Example inferFormula ([vbl "P", vbl "Q"]) = false.

=============================================
%%             inferableToFront
=============================================

Expect inferableToFront: [Formula] -> [Formula]
  %: inferabletoFront(alpha) yields the list of formulas
  %: moved to the front of the formula list. 
  %: If there is no inferable formula in alpha
  %: the unchanged list is returned.
%Expect

Define
--------------------------------------------
  case inferableToFront (alpha) = alpha when not inferFormula (alpha)
  case inferableToFront (alpha) = beta |
    ! y = (select (x |-> inferable(x)) alpha).
    ! beta = y :: alpha -/ y.
--------------------------------------------
%Define

Example inferableToFront ([vbl "P", vbl "Q"]) = [vbl "P", vbl "Q"].

=============================================
%%              isValid
=============================================

Expect isValid: (Maybe of [Sequent]) -> Boolean
 %: isValid returns true if all sequent in list is valid.
 %Expect

Define
--------------------------------------------
  case isValid (something (alpha)) = allSatisfy (x |-> validSequent(x)) alpha
  case isValid (?) = false
--------------------------------------------
%Define

=============================================
%%             tryRules
=============================================

Expect tryRules: (Sequent, [Rule]) -> Boolean
  %: tryRules is true when some rule is capable
  %: of proving the validity of Sequent s.
%Expect

Define
--------------------------------------------
  case tryRules (?, []) = false
  case tryRules (s, h :: t)
    = isValid(h(s)) or tryRules(s, t)
--------------------------------------------
%Define

=============================================
%%             inferLeft
=============================================

Expect inferLeft: Sequent -> Boolean
  %: inferLeft(s) is true if one of the sequent to the left 
  %: is valid
%Expect

--------------------------------------------
Define inferLeft (s) = tryRules (s, [negL, andL, orL, impL]).
--------------------------------------------

=============================================
%%             inferRight
=============================================

Expect inferRight: Sequent -> Boolean
  %: inferRight(s) is true if one of the sequent to the right 
  %: is valid
%Expect

--------------------------------------------
Define inferRight (s) = tryRules (s, [negR, andR, orR, impR]).
--------------------------------------------

=============================================
%%             infer
=============================================

Expect infer: Sequent -> Boolean
  %: infer(s) returns true when some rules in sequent is valid
%Expect

--------------------------------------------
Define infer (alpha |- beta)
  = inferLeft(inferableToFront(alpha) |- beta) or 
    inferRight(alpha |- inferableToFront(beta)).
--------------------------------------------

=============================================
%%             validSequent
=============================================

Expect validSequent: Sequent -> Boolean
  %: validSequent(s) takes a sequent and returns whether the 
  %: sequent is valid or not
%Expect

Expect validSequent: Sequent -> Boolean.

--------------------------------------------
Define validSequent (alpha) = isBasic(alpha) or infer(alpha).
--------------------------------------------

=============================================
%%             valid?
=============================================

--------------------------------------------
Define valid? (alpha) = validSequent([] |- [alpha]).
--------------------------------------------

%Package
