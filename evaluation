;Brian Raytick
;Assignment 3

(define (evaluate E env)
  (cond
    ((number? E) E)
    ((symbol? E)            (evaluateVar E env))
    ((eqv? (car E) 'plus)   (apply + (eval-param (cdr E) env)))
    ((eqv? (car E) 'minus)  (apply - (eval-param (cdr E) env)))
    ((eqv? (car E) 'times)  (apply * (eval-param (cdr E) env)))
    ((eqv? (car E) 'divide) (apply / (eval-param (cdr E) env)))
    ((eqv? (car E) 'if)     (if (= (evaluate (cadr E) env) 0)
                              (evaluate (cadddr E) env) 
                              (evaluate (caddr E) env)
                         
                              )
                            )
    ((eqv? (car E) 'let)    (evaluateLet E env))
    (else '()) ; confused - return ()
   )
)

(define (eval-param E env)
  (if (null? E) '()
      (cons (evaluate (car E) env) (eval-param (cdr E) env))
   )
)

(define (evaluateVar E env)
  (let ((promise (assoc E env)))
    (if (number? (cadr promise))
      (cadr promise)
      (let ((v (evaluate (caadr promise) (cadadr promise))))
        (begin
          (set-car! (cdr promise) v)
           v
        )
      )
    )
  )
)

(define (evaluateLet E env)
  (let* ((x (caadr E))
        (v (cadadr E))
        (e (caddr E))
        (pair (list x (list v env)))
        (newenv (cons pair env))
       )
     (evaluate e newenv)
   )
)

(evaluate '(plus 3 5 4) '())
(evaluate '(minus 5 2 1) '())
(evaluate '(divide 10 5) '())
(evaluate '(times 10 5) '())
(evaluate '(plus (times 2 3) (times 4 2)) '()) 
(evaluate '(plus (times 2 3) (minus 4 2)) '())
(evaluate '(if (minus 2 2) (plus 1 8) (divide 5 2)) '())
(evaluate '(if (plus 1 2) (minus 3 5) (plus 5 6)) '())
(evaluate '(times x 3) '((x 5) (y 2))) 
(evaluate '(times x 3) '((x 5) (x 2)))
(evaluate '(let (s 5) (let (t (plus s s)) (times s (plus t 3)))) '( ))
