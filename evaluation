;Brian Raytick
;Assignment 3

(define (evaluate E env)
  (cond
    ((number? E) E)
    ((symbol? E)            (evaluateVar E env))
    ((eqv? (car E) 'plus)   (apply + (eval-param (cdr E) env)))
    ((eqv? (car E) 'minus)  (apply - (eval-param (cdr E) env)))
    ((eqv? (car E) 'times)  (apply * (eval-param (cdr E) env)))
    ((eqv? (car E) 'divide) (apply / (eval-param (cdr E) env)))
    ((eqv? (car E) 'if)     (if (= (evaluate (cadr E) env) 0)
                              (evaluate (cadddr E) env) 
                              (evaluate (caddr E) env)
                         
                              )
                            )
    ((eqv? (car E) 'let)    (evaluateLet E env))
    (else '()) ; confused - return ()
   )
)

(define (eval-param E env)
  (if (null? E) '()
      (cons (evaluate (car E) env) (eval-param (cdr E) env))
   )
)

(define (evaluateVar E env)
  (let ((promise (assoc E env)))
    (if (number? (cadr promise))
      (cadr promise)
      (let ((v (evaluate (caadr promise) (cadadr promise))))
        (begin
          (set-car! (cdr promise) v)
           v
        )
      )
    )
  )
)

(define (evaluateLet E env)
  (let* ((x (caadr E))
        (v (cadadr E))
        (e (caddr E))
        (pair (list x (list v env)))
        (newenv (cons pair env))
       )
     (evaluate e newenv)
   )
)

(evaluate '(plus 1 2 3) '())
(evaluate '(minus 8 3 1) '())
(evaluate '(divide 20 5) '())
(evaluate '(times 10 5) '())
(evaluate '(plus (times 1 3) (times 5 2)) '()) 
(evaluate '(plus (times 2 3) (minus 5 1)) '())
(evaluate '(if (minus 3 2) (plus 1 9) (divide 6 2)) '())
(evaluate '(if (plus 2 2) (minus 4 5) (plus 6 6)) '())
(evaluate '(times x 2) '((x 6) (y 3))) 
(evaluate '(times x 3) '((x 5) (x 3)))
(evaluate '(let (n 2) (let (m (plus n n)) (times s (plus m 5)))) '( ))
