/********************
* Author: Brian Raytick
* Date: 09/07/2016
 *********************/
 
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include "util.h"

static target_t t_array[ MAX_NODES ];
static int numTargets = 0;

int check_exec = TRUE;
int check_time = TRUE;

int parse(char * lpszFileName)
{
    int nLine=0;
    char szLine[1024];
    char * lpszLine;
    FILE * fp = file_open( lpszFileName );

    int numTokens = 0;
    char **tokens;
    const char delimiter[ 2 ] = " ";

    char* target = "";
    target_t * active;
    int n = 0;
    int i;

    if( fp == NULL )
    {
        return -1;
    }

    while( file_getline( szLine, fp ) != NULL )
    {
        lpszLine = strtok(szLine, "\n");
        numTokens = makeargv(lpszLine, delimiter, &tokens);

        if( numTokens > 0 )
        {
            if(tokens[0][0] == '\t')
            {
                strcpy( (*active).szCommand, &lpszLine[1]);
            }
            else if( tokens[0][0] == ' ' )
            {
                fprintf(stderr, "White space not tolerated. \n");
                fclose(fp);
                return -1;
            }
            else if ( tokens[0][0] == '#' );
            else
            {
                active = &t_array[ n ];
                tokens[0][strlen(tokens[0]) - 1] = 0;
                for( i = 0 ; i < numTargets ; i++)
                {
                    if( !strcmp(t_array[i].szTarget, tokens[0]))
                    {
                        fprintf(stderr, "Duplicate targets not tolerated. \n");
                        fclose(fp);
                        return -1; 
                    }
                }
                numTargets++;
                strcpy( (*active).szTarget, tokens[0] );
                for( i = 1 ; i < numTokens ; i++ )
                {
                    strcpy( (*active).szDependencies[ i - 1 ], tokens[ i ] );
                }
                (*active).nDependencyCount = numTokens - 1;
                if (!(numTokens - 1))
                {
                    ( *active ).nStatus = READY;
                }
                else
                {
                    (*active).nStatus = INELIGIBLE;
                }
                n++;
            }
        }
    }
    fclose(fp);
    return 0;
}

int execute_DAG( char * target )
{
    int n;
    pid_t childpid[10];
    int t_index = 0;
    int found = FALSE;
    char ** commandArgs;
    int numTokens = 0;
    int mod_time;
    int execute = FALSE;
    int status;
    for( n = 0 ; n < numTargets ; n++)
    {
        if( !(strcmp( t_array[n].szTarget , target )) )
        {
            t_index = n;
            found = TRUE;
        }
    }
    if( !found )
    {
        if(!is_file_exist(target))
        {
            #ifdef DEBUG
            printf("its a file \n");
            #endif
            exit(FINISHED);
        }
        else
        {
            fprintf(stderr, "Target not found. \n");
            exit( NOT_FOUND );
        }
    }
    if( t_array[t_index].nStatus == INELIGIBLE )
    {
        for( n = 0; n < t_array[t_index].nDependencyCount ; n++ )
        {
            childpid[n] = fork();
            if (childpid[n] == 0)
            {
                execute_DAG( t_array[t_index].szDependencies[n] );
            }
        }
        for( n = t_array[t_index].nDependencyCount ; n > 0 ; n-- )
        {
            while(wait(&status), WEXITSTATUS(status) == RUNNING);
            if( !WIFEXITED(status) || WEXITSTATUS(status) == EXIT_FAILURE || WEXITSTATUS(status) == NOT_FOUND ){
                _exit(EXIT_FAILURE);
            }
        }
        t_array[t_index].nStatus = READY;
    }
    if( t_array[t_index].nStatus == READY )
    {
        if( t_array[t_index].szCommand[0] != '\0')
        {
            numTokens = makeargv( t_array[t_index].szCommand , " ",  &commandArgs );
            if(check_time)
            {
                if(!t_array[t_index].nDependencyCount)
                {
                    execute = TRUE;
                }
                else
                {
                    for(n = 0 ; n < t_array[t_index].nDependencyCount ; n++)
                    {
                        mod_time = compare_modification_time( t_array[t_index].szTarget, t_array[t_index].szDependencies[n]);
                        if( mod_time == -1 || mod_time == 2 )
                        {
                            execute = TRUE;
                        }
                    }
                }
            }
            else
            {
                execute = TRUE;
            }
            t_array[t_index].nStatus = FINISHED;
            if(execute)
            {
                if(check_exec)
                {

                    #ifdef DEBUG
                    printf("I will execute now \n");
                    #endif

                    execvp(commandArgs[0] , commandArgs );

                    fprintf(stderr, "Exec failed. \n");
                    _exit( EXIT_FAILURE );
                }
                else
                {
                    fprintf(stdout,"%s\n",t_array[t_index].szCommand);
                }
            }
        }
    exit(FINISHED);
    }
    else if( t_array[t_index].nStatus == RUNNING )
    {
        exit( RUNNING );
    }
    else if( t_array[t_index].nStatus == FINISHED )
    {
        exit( FINISHED );
    }
}

void show_error_message( char * lpszFileName )
{
    fprintf(stderr, "Usage: %s [options] [target] : only single target is allowed.\n", lpszFileName);
    fprintf(stderr, "-f FILE\t\tRead FILE as a maumfile.\n");
    fprintf(stderr, "-h\t\tPrint this message and exit.\n");
    fprintf(stderr, "-n\t\tDon't actually execute commands, just print them.\n");
    fprintf(stderr, "-B\t\tDon't check files timestamps.\n");
    fprintf(stderr, "-m FILE\t\tRedirect the output to the file specified .\n");
    exit(0);
}

int main(int argc, char **argv)
{
    extern int optind;
    extern char * optarg;
    int ch;
    char * format = "f:hnBm:";
    char szMakefile[64] = "Makefile";
    char szTarget[64];
    char szLog[64];
    int log_fd;

    while((ch = getopt(argc, argv, format)) != -1)
    {
        switch(ch)
        {
        case 'f':
            strcpy(szMakefile, strdup(optarg));
            break;
        case 'n':
            check_exec = FALSE;
            break;
        case 'B':
            check_time = FALSE;
            break;
        case 'm':
            strcpy(szLog, strdup(optarg));

            log_fd = open(szLog, CREATE_FLAGS, CREATE_MODE);

            if (log_fd == -1)
            {
                fprintf(stderr, "File open failed");
                return -1;
            }
            if(dup2(log_fd, STDOUT_FILENO) == -1)
            {
                fprintf(stderr, "File redirection failed\n");
                return -1;
            }
            if(close(log_fd) == -1)
            {
                fprintf(stderr, "File close failed");
            }

            break;
        default:
            show_error_message(argv[0]);
            exit(1);
        }
    }

    argc -= optind;
    argv += optind;
    
    if(argc > 1)
    {
        show_error_message(argv[0]);
        return EXIT_FAILURE;
    }
    if((parse(szMakefile)) == -1)
    {
        return EXIT_FAILURE;
    }
    if(argc == 1)
    {
        strcpy(szTarget, argv[0]);
    }
    else
    {
        strcpy(szTarget, t_array[0].szTarget);
    }

    #ifdef DEBUG
    printf("argc : %d \n", argc);
    printf("argv[0] : %s \n", argv[0]);
    printf("szMakefile : %s \n", szMakefile);
    printf("szTarget : %s \n", szTarget);
    #endif

    pid_t childpid;
    int status;
    childpid = fork();
    if(!childpid)
    {
        execute_DAG(szTarget);
    }
    wait(&status);
    if(!WIFEXITED(status) || WEXITSTATUS(status) == EXIT_FAILURE)
    {
        printf("Failure. \n");
        return EXIT_FAILURE;
    }
    #ifdef DEBUG
    printf("I finished!\n");
    #endif
    return EXIT_SUCCESS;
}
